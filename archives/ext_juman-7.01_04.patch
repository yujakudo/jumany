diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/configure juman-7.01/configure
--- B:/msys64/tmp/juman-7.01/configure	Mon Dec 15 09:50:09 2014
+++ juman-7.01/configure	Sun Sep 24 19:51:02 2017
@@ -10488,7 +10488,7 @@ CC="$lt_save_CC"
 
 
 
-LIBJUMAN_VERSION_INFO="4:0:0"
+LIBJUMAN_VERSION_INFO="4:0:1"
 
 
 # Checks for libraries.
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/juman/client.c juman-7.01/juman/client.c
--- B:/msys64/tmp/juman-7.01/juman/client.c	Mon Sep 26 17:55:47 2011
+++ juman-7.01/juman/client.c	Wed Oct 25 17:32:30 2017
@@ -337,12 +337,7 @@ static int open_connection(server, port)
   引数としてargcを追加オプションの扱いをJUMAN用へ変更
   NACSIS 吉岡
 */
-int juman_client(argc, argv, server, port)
-    int argc;
-    char **argv;
-    char *server;
-    int port;
-{
+int juman_client(int argc, char **argv, char *server, int port) {
     int pid, sfd;
     char *option;
     FILE *ifp, *ofp;
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/juman/juman.c juman-7.01/juman/juman.c
--- B:/msys64/tmp/juman-7.01/juman/juman.c	Tue Dec 27 17:29:53 2011
+++ juman-7.01/juman/juman.c	Tue Oct 31 18:57:18 2017
@@ -15,6 +15,7 @@
 #endif
 
 #include	<juman.h>
+#include "json_parse.h"
 
 /*
 ------------------------------------------------------------------------------
@@ -46,6 +47,9 @@ extern U_CHAR	        String[LENMAX];
 int             JUMAN_server_mode = FALSE;
 int             JUMAN_server_foreground = FALSE;
 
+char * infile_Opt = NULL;
+char * outfile_Opt = NULL;
+
 #define JUMAN_PORT   32000
 #ifndef MAXHOSTNAMELEN
 #define MAXHOSTNAMELEN 64
@@ -54,6 +58,18 @@ int             JUMAN_server_foreground 
 static char juman_host[MAXHOSTNAMELEN];
 static unsigned short juman_port = JUMAN_PORT;
 
+extern int juman_client(int argc, char **argv, char *server, int port);
+extern int compile_unkword_patterns();
+
+extern BOOL	juman_init_rc(FILE *fp);
+extern void juman_init_etc(void);
+extern int	juman_close(void);
+extern int	juman_sent(void);
+extern char	**print_best_path(FILE* output);
+extern char	**print_all_mrph(FILE* output);
+extern char	**print_all_path(FILE* output);
+extern char	**print_homograph_path(FILE* output);
+
 
 /*
 ------------------------------------------------------------------------------
@@ -78,6 +94,7 @@ void    juman_standalone(void);
 void    juman_server(char **argv, int port, int foreground);
 static void set_juman_port(char* port);
 static void set_juman_server(char* server);
+static void dic_version(int detail, char * jumanrc);
 
 /*
 ------------------------------------------------------------------------------
@@ -151,7 +168,10 @@ int readtonl(FILE *fp)
 
 void juman_standalone(void)
 {
-    int length;
+	int length;
+	char * String;
+	size_t buff_size;
+	FILE *fd_in, *fd_out;
     
     if (!juman_init_rc(Jumanrc_Fileptr)) {	/* rcfile関係の初期化 */
 	fprintf(stderr, "error in .jumanrc\n");
@@ -161,20 +181,36 @@ void juman_standalone(void)
 #ifdef HAVE_REGEX_H
     if (Onomatopoeia_Opt) Unkword_Pat_Num = compile_unkword_patterns();
 #endif
+	//	for convert encoding
+	String = get_input_buff(&buff_size);
+	fd_in = stdin;
+	fd_out = stdout;
+	if(NULL != infile_Opt) {
+		if(NULL==(fd_in = fopen(infile_Opt, "rb"))) {
+			fprintf(stderr, "Cannot open file to read.(%s)\n", infile_Opt);
+			return;
+		}
+	}
+	if(NULL != outfile_Opt) {
+		if(NULL==(fd_out = fopen(outfile_Opt, "wb"))) {
+			fprintf(stderr, "Cannot open file to write.(%s)\n", outfile_Opt);
+			return;
+		}
+	}
 
-    String[LENMAX - 1] = '\n';
-    while ( fgets(String, LENMAX, stdin) != NULL ) {
-	if (String[LENMAX - 1] != '\n') {
-	    String[LENMAX - 1] = '\0';
+    String[buff_size - 1] = '\n';
+    while ( fgets(String, buff_size, fd_in) != NULL ) {
+	if (String[buff_size - 1] != '\n') {
+	    String[buff_size - 1] = '\0';
 	    fprintf(stderr, "Too long input string (%s).\n", String);
-	    String[LENMAX - 1] = '\n';
-	    readtonl(stdin);
+	    String[buff_size - 1] = '\n';
+	    readtonl(fd_in);
 	    continue;
 	}
 	
 	length = strlen(String);
-	if (length == LENMAX-1 && String[length - 1] != '\n') {
-	    fprintf(stderr, "Too long input string (%s).\n", String);
+	if (length == buff_size-1 && String[length - 1] != '\n') {
+	    enc_fprintf(stderr, "Too long input string (%s).\n", String);
 	    continue;
 	} else {
 #ifdef _WIN32
@@ -187,27 +223,27 @@ void juman_standalone(void)
 
 	if (Show_Opt_tag[0])
 	    if (!strncmp(String , Show_Opt_tag , strlen(Show_Opt_tag))) {
-		fprintf(stdout, "%s JUMAN:%s\n", String, VERSION);
-		continue;
+			enc_fprintf(fd_out, "%s JUMAN:%s\n", String, VERSION);
+			continue;
 	    }
 
 	if (juman_sent() == TRUE) {
 	    switch (Show_Opt1) {
 	    case Op_B:
-		print_best_path(stdout); break;
+		print_best_path(fd_out); break;
 	    case Op_M:
-		print_all_mrph(stdout); break;
+		print_all_mrph(fd_out); break;
 	    case Op_P:
-		print_all_path(stdout); break;
+		print_all_path(fd_out); break;
 	    case Op_BB:
 	    case Op_PP:
-		print_homograph_path(stdout); break;
+		print_homograph_path(fd_out); break;
 	    default:
 		break;
 	    }
 	}
-	fprintf(stdout, "EOS\n");
-	fflush(stdout);
+	fprintf(fd_out, "EOS\n");
+	fflush(fd_out);
     }
     juman_close();
 }
@@ -231,7 +267,8 @@ void juman_standalone(void)
 void option_proc(int argc, char **argv)
 {
     int 	i;
-
+	int dicv_detail = -1;	
+	
     Show_Opt1 = Op_BB;
     Show_Opt2 = Op_E2;
     Show_Opt_jumanrc = 0;
@@ -243,7 +280,7 @@ void option_proc(int argc, char **argv)
     Repetition_Opt = 1;
     Onomatopoeia_Opt = 1;
     LongSoundRep_Opt = 1;
-    LongSoundDel_Opt = 1;
+	LongSoundDel_Opt = 1;
 
     for ( i=1; i<argc; i++ ) {
 	if ( argv[i][0] != '-' ) {
@@ -301,12 +338,30 @@ else {
 		    }
 		    else if ( argv[i][0] == 'o' && argv[i][1] == 'n' && argv[i][2] == 'o') {
 			Repetition_Opt = Onomatopoeia_Opt = 0; /* onomatopoeia */
-		    }
+			}
 		    else {
 			juman_help();				  
 		    }
 		}
-	    }
+	    } else if(argv[i][1] == '-') {
+			//	Extended options
+			if(0==strncmp(argv[i], "--enc", 5)) {
+				set_encoding_opt(argv[++i]);
+			} else if(0==strncmp(argv[i], "--if", 4)) {
+				infile_Opt = argv[++i];
+			} else if(0==strncmp(argv[i], "--of", 4)) {
+				outfile_Opt = argv[++i];
+			} else if(0==strncmp(argv[i], "--dicv", 6)) {
+				if(i+1 == argc ) {
+					dicv_detail = 0;
+				} else {
+					dicv_detail = atoi(argv[i+1]);
+					if(dicv_detail || 0==strcmp(argv[i+1], "0")) {
+						i++;
+					}
+				}
+			}
+		}
 	    /* サーバーモード用のオプションの取扱い */
             else if ( argv[i][1] == 'S' ) JUMAN_server_mode = TRUE;
 #if ! defined _WIN32
@@ -328,7 +383,10 @@ else {
 		juman_help();
 	    }
 	}
-    }
+	}
+	if(dicv_detail>=0) {
+		dic_version(dicv_detail, (Show_Opt_jumanrc ? argv[Show_Opt_jumanrc]: NULL));
+	}
 }
 
 static void set_juman_port(char *port)
@@ -377,7 +435,11 @@ void juman_help()
     fprintf(stderr, "             -u : disable unknown word processing\n");
     fprintf(stderr, "             -i : ignore an input line starting with 'string'\n");
     fprintf(stderr, "             -r : use 'rc_file' as '.jumanrc'\n");
+    fprintf(stderr, "             --if FILEPATH: path to input file\n");
+    fprintf(stderr, "             --of FILEPATH: path to output file\n");
+    fprintf(stderr, "             --enc ENCODING: encoding e.g.'CP932', 'sjis,utf-8'\n");
     fprintf(stderr, "             -v : show version\n");
+    fprintf(stderr, "             --dicv <0-2>: show dictionary version\n");
     fprintf(stderr, "\n");
     fprintf(stderr, "             -S : start JUMAN server\n");
 #if ! defined _WIN32
@@ -395,3 +457,13 @@ void juman_version()
     fprintf(stderr, "%s %s\n", PACKAGE_NAME, VERSION);
     exit(0);
 }
+
+static void dic_version(int detail, char * jumanrc) {
+	set_jumanrc_fileptr(jumanrc, TRUE, TRUE);
+    if (juman_init_rc(Jumanrc_Fileptr)) {
+		dici_print(NULL, detail);		
+	} else {
+		fprintf(stderr, "error in .jumanrc\n");
+	}
+    exit(0);
+}
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/juman/server.c juman-7.01/juman/server.c
--- B:/msys64/tmp/juman-7.01/juman/server.c	Wed Nov 16 08:23:45 2011
+++ juman-7.01/juman/server.c	Wed Oct 25 17:42:36 2017
@@ -45,7 +45,9 @@
 
 #include <juman.h>
 
+#ifndef errno
 extern int errno;
+#endif
 
 #ifndef SOMAXCONN
 #define SOMAXCONN 5
@@ -81,7 +83,15 @@ extern int              LongSoundDel_Opt
 extern U_CHAR	        String[LENMAX];
 
 #define JUMAN_INPUT_SIZE  8192
-   
+
+extern BOOL	juman_init_rc(FILE *fp);
+extern void juman_init_etc(void);
+extern int	juman_sent(void);
+extern char	**print_best_path(FILE* output);
+extern char	**print_all_mrph(FILE* output);
+extern char	**print_all_path(FILE* output);
+extern char	**print_homograph_path(FILE* output);
+
 /*
  * skip_until_EOf()
  */
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/encoder.c juman-7.01/lib/encoder.c
--- B:/msys64/tmp/juman-7.01/lib/encoder.c	Thu Jan  1 00:00:00 1970
+++ juman-7.01/lib/encoder.c	Fri Oct  6 11:23:03 2017
@@ -0,0 +1,245 @@
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include "encoder.h"
+
+static void enc_stream_init(ENC_STREAM_T *pstream);
+static bool enc_stream_set(
+	ENC_STREAM_T *pstream, const char * const * pencodings, 
+	size_t buff_size, char ** pbuffs);
+static bool enc_stream_alloc(ENC_STREAM_T *pstream, int idx);
+static void enc_stream_free(ENC_STREAM_T *pstream);
+static bool enc_stream_convert(ENC_STREAM_T *pstream);
+
+///	New encoder
+///	@param buff_input_write Default buffer to write input. if NULL, newly allocates.
+/// @param size_input Size of buffer for input.
+///	@param buff_output_read Default buffer to read output. if NULL, newly allocates.
+/// @param size_output Size of buffer for output.
+/// @return Pointer of encoder. Or NULL, if failed.
+ENCODER_T * encoder_new(
+	char * buff_input_write, size_t size_input,
+	char * buff_output_read, size_t size_output) {
+	
+	ENCODER_T * penc;
+	if(NULL==(penc = malloc(sizeof(ENCODER_T)))) return NULL;
+	enc_stream_init(&(penc->in));
+	enc_stream_init(&(penc->out));
+	//	temporaly store
+	penc->in.buff[1] = buff_input_write;
+	penc->in.size = size_input;
+	penc->out.buff[0] = buff_output_read;
+	penc->out.size = size_output;
+	return penc;
+}
+
+///	Delete encoder
+///	@param penc Encoder properties.
+void encoder_delete(ENCODER_T *penc) {
+	if(NULL==penc) return;
+	enc_stream_free(&(penc->in));
+	enc_stream_free(&(penc->out));
+	free(penc);
+}
+
+///	Set encodings
+///	@param penc Encoder properties.
+/// @param s_inner Name of inner encoding. If NULL or null string, set to UTF-8
+/// @param s_inout Comma separated string of input and output encoding.
+///	If comma does not exist, both input and output encoding considered this value.
+///	If NULL or null string, considered same as inner encoding and will not do encoding.
+bool encoder_set_encoding(ENCODER_T *penc, const char * s_inner, const char * s_inout) {
+	char s_io[ENC_NAME_LEN*2];
+	char * s_incode, * s_outcode;
+	const char * encodings[2];
+	char * buffers[2];
+
+	if(NULL==s_inner || 0==s_inner[0])	s_inner = "UTF-8";
+	s_io[0] = 0;
+	if(NULL!=s_inout) strncpy(s_io, s_inout, sizeof(s_io));
+	s_io[sizeof(s_io)-1] = 0;
+	//	split s_inout
+	s_incode = s_outcode = s_io;
+	while(*s_outcode!=0 && *s_outcode!=',') s_outcode++;
+	if(*s_outcode==',') *s_outcode++ = 0;		
+	else s_outcode = s_incode;
+	//	set input stream
+	encodings[0] = s_incode;
+	buffers[0] = NULL;
+	encodings[1] = s_inner;
+	buffers[1] = penc->in.buff[1];
+	if(!enc_stream_set(&(penc->in), encodings,  penc->in.size, buffers)) {
+		return false;
+	}
+	//	set output stream
+	encodings[0] = s_inner;
+	buffers[0] = penc->out.buff[0];
+	encodings[1] = s_outcode;
+	buffers[1] = NULL;
+	if(!enc_stream_set(&(penc->out), encodings,  penc->out.size, buffers)) {
+		return false;
+	}
+	return true;
+}
+
+///	Get input buffer to write.
+///	@param penc Encoder properties.
+/// @param direction. Stream direction. ENC_IN(0) or ENC_OUT(1)
+/// @param port. Port of stream. ENC_WRITE(0) or ENC_READ(1)
+///	@param psize [out]Pointer to write buffer size.
+/// @return buffer pointer.
+char * encoder_getbuff(ENCODER_T *penc, int direction, int port, size_t *psize) {
+	ENC_STREAM_T *pstream;
+	pstream = direction? &(penc->out): &(penc->in);
+	*psize = pstream->size;
+	return pstream->buff[port];
+}
+
+/// Conver encoding.
+///	@param penc Encoder properties.
+/// @param direction. ENC_IN(0) or ENC_OUT(1)
+/// @return Success or fail
+bool encoder_convert(ENCODER_T *penc, int direction) {
+	ENC_STREAM_T *pstream;
+	const char * s_direc;
+	pstream = direction? &(penc->out): &(penc->in);
+	s_direc = direction? "output": "input";
+	if(false==enc_stream_convert(pstream)) {
+		fprintf(stderr, "Fail to convert %s encoding.(%s)\n", s_direc, pstream->buff[0]);
+		return false;
+	}
+	return true;
+}
+
+/// Check needs to convert.
+///	@param penc Encoder properties.
+/// @param direction. ENC_IN or ENC_OUT
+/// @return true if needs conversion, or false.
+bool encoder_needs(ENCODER_T *penc, int direction) {
+	ENC_STREAM_T *pstream;
+	pstream = direction? &(penc->out): &(penc->in);
+	return (IC_FALSE==pstream->ic)? false: true;
+}
+
+/// printf with coverting.
+///	@param penc Encoder properties.
+///	@param stream stream to output.
+/// @param format Format will be filled with following arguments.
+/// @return Success or fail
+bool encoder_printf(ENCODER_T *penc, FILE * stream, const char * format, ...) {
+	va_list va;
+	bool result;
+
+	va_start(va, format);
+	result = encoder_vprintf(penc, stream, format, va);
+	va_end(va);
+	return result;
+}
+
+/// vprintf with coverting.
+///	@param penc Encoder properties.
+///	@param stream stream to output.
+/// @param format Format.
+/// @param va Argumets to fill format with.
+/// @return Success or fail
+bool encoder_vprintf(ENCODER_T *penc, FILE * stream, const char * format, va_list va) {
+	int result;
+	ENC_STREAM_T *pstream;
+
+	if(stream==stderr || IC_FALSE==penc->out.ic) {
+		vfprintf(stream, format, va);
+		return true;
+	}
+	pstream = &(penc->out);
+	result = vsnprintf(pstream->buff[0], pstream->size, format, va);
+	if(result<0 || pstream->size<=result) {
+		fprintf(stderr, "Fail to fill format in encoder_printf.(%s)\n", format);
+		return false;
+	}
+	if(false==enc_stream_convert(pstream)) {
+		fprintf(stderr, "Fail to convert encoding in encoder_printf.(%s)\n", pstream->buff[0]);
+		return false;
+	}
+	fprintf(stream, pstream->buff[1]);
+	return true;
+}
+
+static void enc_stream_init(ENC_STREAM_T *pstream) {
+	pstream->ic = IC_FALSE;
+	pstream->size = 0;
+	pstream->buff[0] = pstream->buff[1] = NULL;
+	pstream->b_alloced[0] = pstream->b_alloced[1] = false;
+}
+
+static bool enc_stream_set(
+	ENC_STREAM_T *pstream, const char * const * pencodings, 
+	size_t buff_size, char ** pbuffs) {
+
+	int i;
+	if( pencodings[0][0]==0 || pencodings[1][0]==0
+		|| 0==strcasecmp(pencodings[0], pencodings[1])) {
+
+		//	No needs to convert. both buffers are same.
+		if(NULL==pbuffs[0] && NULL==pbuffs[1]) {
+			if(!enc_stream_alloc(pstream, 0)) return false;
+			pstream->buff[1] = pstream->buff[0];
+		} else if(NULL==pbuffs[1]) {
+			pstream->buff[0] = pstream->buff[1] = pbuffs[0];
+		} else {
+			pstream->buff[0] = pstream->buff[1] = pbuffs[1];
+		}
+		return true;
+	}
+	//	open iconv
+	pstream->ic = iconv_open(pencodings[1], pencodings[0]);
+	if(IC_FALSE==pstream->ic) {
+		fprintf(stderr, "Encoding name(%s or %s) is not avairable.\n", pencodings[0],  pencodings[1]);
+		return false;
+	}
+	//	allocate buffer
+	pstream->size = buff_size;
+	for(i=0; i<2; i++) {
+		pstream->buff[i] = pbuffs[i];
+		if(!enc_stream_alloc(pstream, i)) return false;
+	}
+	return true;
+}
+
+static bool enc_stream_alloc(ENC_STREAM_T *pstream, int idx) {
+	if(NULL==pstream->buff[idx]) {
+		if(NULL==(pstream->buff[idx] = malloc(pstream->size))) {
+			fprintf(stderr, "Fail to allocate buffer in encoder.\n");
+			return false;
+		}
+		pstream->b_alloced[idx] = true;
+	}
+	return true;
+}
+
+static void enc_stream_free(ENC_STREAM_T *pstream) {
+	int i;
+	if(IC_FALSE != pstream->ic)	{
+		iconv_close(pstream->ic);
+		pstream->ic = IC_FALSE;
+	}
+	for(i=0; i<2; i++) {
+		if(pstream->b_alloced[i]) {
+			free(pstream->buff[i]);
+			pstream->b_alloced[i] = false;
+		}
+	}	
+}
+
+static bool enc_stream_convert(ENC_STREAM_T *pstream) {
+	char *pinbuf, *poutbuf;
+	size_t inbuf_size, outbuf_size, result;
+
+	if(IC_FALSE==pstream->ic) return true;	//	nothing to do
+	pinbuf = pstream->buff[0];
+	poutbuf = pstream->buff[1];
+	inbuf_size = strlen(pinbuf);
+	outbuf_size = pstream->size - 1;
+	result = iconv(pstream->ic, &pinbuf, &inbuf_size, &poutbuf, &outbuf_size );
+	*poutbuf = 0;
+	return ((size_t)-1 == result)? false: true;
+}
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/encoder.h juman-7.01/lib/encoder.h
--- B:/msys64/tmp/juman-7.01/lib/encoder.h	Thu Jan  1 00:00:00 1970
+++ juman-7.01/lib/encoder.h	Fri Sep 22 14:48:40 2017
@@ -0,0 +1,107 @@
+#ifndef ENCODER_H
+#define ENCODER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdbool.h>
+#include <iconv.h>
+
+
+//	Length of encoding name;
+#define ENC_NAME_LEN	(22)
+//	Direction of stream
+#define ENC_IN (0)
+#define ENC_OUT (1)
+//	Port of stream
+#define ENC_WRITE (0)
+#define ENC_READ (1)
+
+typedef struct enc_stream_t {
+	iconv_t ic;			///	iconv descripter
+	char *	buff[2];	///	buffers.
+	bool b_alloced[2];	///	buff is allocated
+	size_t	size;		///	buffer size
+} ENC_STREAM_T;
+
+///	Properties
+typedef struct encoder_t {
+	ENC_STREAM_T	in;
+	ENC_STREAM_T	out;
+} ENCODER_T;
+
+#define IC_FALSE	((iconv_t)-1)
+///	ENCODER_NEEDS is same as encoder_needs
+///	but fast and will be optimized
+#define ENCODER_NEEDS(penc, direction) ( \
+	(((direction)? (penc)->out: (penc)->in).ic==IC_FALSE)? false: true \
+)
+
+///	New encoder
+///	@param buff_input_write Default buffer to write input. if NULL, newly allocates.
+/// @param size_input Size of buffer for input.
+///	@param buff_output_read Default buffer to read output. if NULL, newly allocates.
+/// @param size_output Size of buffer for output.
+/// @return Pointer of encoder. Or NULL, if failed.
+ENCODER_T * encoder_new(
+	char * buff_input_write, size_t size_input,
+	char * buff_output_read, size_t size_output);
+
+///	Delete encoder
+///	@param penc Encoder properties.
+void encoder_delete(ENCODER_T *penc);
+
+///	Set encodings
+///	@param penc Encoder properties.
+/// @param s_inner Name of inner encoding. If NULL or null string, set to UTF-8
+/// @param s_inout Comma separated string of input and output encoding.
+///	If comma does not exist, both input and output encoding considered this value.
+///	If NULL or null string, considered same as inner encoding and will not do encoding.
+bool encoder_set_encoding(ENCODER_T *penc, 
+	const char * s_inner, const char * s_inout);
+
+///	Get input buffer to write.
+///	@param penc Encoder properties.
+/// @param direction. Stream direction. ENC_IN(0) or ENC_OUT(1)
+/// @param port. Port of stream. ENC_WRITE(0) or ENC_READ(1)
+///	@param psize [out]Pointer to write buffer size.
+/// @return buffer pointer.
+extern char * encoder_getbuff(ENCODER_T *penc, 
+	int direction, int port, size_t *psize);
+
+/// Conver encoding.
+///	@param penc Encoder properties.
+/// @param direction. ENC_IN(0) or ENC_OUT(1)
+/// @return Success or fail
+extern bool encoder_convert(ENCODER_T *penc, int direction);
+
+/// Check needs to convert.
+///	@param penc Encoder properties.
+/// @param direction. ENC_IN or ENC_OUT
+/// @return true if needs conversion, or false.
+extern bool encoder_needs(ENCODER_T *penc, int direction);
+
+/// printf with coverting.
+///	@param penc Encoder properties.
+///	@param stream stream to output.
+/// @param format Format will be filled with following arguments.
+/// @return Success or fail
+bool encoder_printf(ENCODER_T *penc, 
+	FILE * stream, const char * format, ...);
+
+/// vprintf with coverting.
+///	@param penc Encoder properties.
+///	@param stream stream to output.
+/// @param format Format.
+/// @param va Argumets to fill format with.
+/// @return Success or fail
+extern bool encoder_vprintf(ENCODER_T *penc, 
+	FILE * stream, const char * format, va_list va);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	//	ENCODER_H
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/ext_api.c juman-7.01/lib/ext_api.c
--- B:/msys64/tmp/juman-7.01/lib/ext_api.c	Thu Jan  1 00:00:00 1970
+++ juman-7.01/lib/ext_api.c	Fri Oct  6 11:19:53 2017
@@ -0,0 +1,273 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "juman.h"
+#include "ext_api.h"
+
+typedef struct ext_t {
+	char * in_buf;
+	size_t in_buf_size;
+	char * word_buf;
+	size_t word_buf_size;
+	EXT_MRPH_T * mrphs_buf;
+	int max_mrphs;
+	int pos;
+} EXT_T;
+
+//	Store in global
+EXT_T Dext;
+char * NullStr = "";
+
+extern FILE * Jumanrc_Fileptr;
+extern BOOL set_jumanrc_fileptr_min(const char *option_rcfile);
+extern BOOL	juman_init_rc(FILE *fp);
+extern void juman_init_etc(void);
+extern int	juman_close(void);
+extern int juman_sent(void);
+extern MRPH *prepare_path_mrph(int path_num , int para_flag);
+extern void set_encoding_opt(const char * s_encoding);
+
+extern int p_buffer_num;
+extern PROCESS_BUFFER * p_buffer;
+extern int * path_buffer;
+extern U_CHAR midasi1[MIDASI_MAX];
+extern U_CHAR midasi2[MIDASI_MAX];
+extern U_CHAR yomi[MIDASI_MAX];
+extern CLASS		Class[CLASSIFY_NO + 1][CLASSIFY_NO + 1];
+extern TYPE		Type[TYPE_NO];
+extern FORM		Form[TYPE_NO][FORM_NO];
+
+static char * wordcopy(char **pword_pos, size_t *pword_buf_rest, const char * word);
+
+#define free(buff) { \
+	if( (buff)==NULL) free((buff)); \
+	(buff) = NULL; \
+}
+
+///	Set encoding
+///	It must be called before ext_init.
+///	If specified wrong encoding name, error will occure in ext_init.
+/// @param s_encoding Comma separated string of input and output encoding.
+///	If comma does not exist, both input and output encoding considered this value.
+///	If NULL or null string, considered same as inner encoding and will not do encoding.
+void ext_set_encoding(const char *s_encoding) {
+	set_encoding_opt(s_encoding);
+}
+	
+///	Initialize lib
+///	@param s_rcfile	Path to jumanrc
+///	@param word_buf_size Word buffer size. It is copied midasi1, yomi, and midasi2.
+///	@param max_mrphs Morpheme buffer size in number. 
+///	@return 
+///	- EXT_SUCCESS:	Success 
+///	- EXT_RC_ERROR:	Resource file error.
+///	- EXT_MALLOC_ERROR:	Cannot allocate memory.
+EXT_RES_CODE ext_init(const char *s_rcfile, size_t word_buf_size, int max_mrphs) {
+	if(FALSE==set_jumanrc_fileptr_min(s_rcfile))	return EXT_FILE_NOT_EXISTS;
+	if(FALSE==juman_init_rc(Jumanrc_Fileptr)) return EXT_RC_ERROR;
+    juman_init_etc();
+#ifdef HAVE_REGEX_H
+	Unkword_Pat_Num = compile_unkword_patterns();
+#endif
+	Dext.in_buf = get_input_buff(&(Dext.in_buf_size));
+	Dext.word_buf_size = word_buf_size? word_buf_size: LENMAX;
+	Dext.max_mrphs = max_mrphs? max_mrphs: DEF_MAX_ITEMS;
+	Dext.word_buf = malloc(Dext.word_buf_size);
+	Dext.mrphs_buf = malloc(sizeof(EXT_MRPH_T) * Dext.max_mrphs);
+	if(NULL==Dext.word_buf || NULL==Dext.mrphs_buf) {
+		free(Dext.word_buf);
+		free(Dext.mrphs_buf);
+		return EXT_MALLOC_ERROR;
+	}
+	Dext.pos = -1;
+	return EXT_SUCCESS;
+}
+
+///	Close extlib
+void ext_close() {
+	free(Dext.word_buf);
+	free(Dext.mrphs_buf);
+	juman_close();
+}
+	
+///	Get input buffer to write.
+///	@param psize [out]Buffer size.
+///	@return Buffer address.
+char * ext_get_input_buff(size_t *psize) {
+	*psize = Dext.in_buf_size;
+	return Dext.in_buf;
+}
+
+///	Get morpheme buffer to read.
+///	@return Buffer address.
+EXT_MRPH_T * ext_get_mrph_buff() {
+	return Dext.mrphs_buf;
+}
+
+///	Analyze with best path
+///	@return 
+///	- EXT_SUCCESS:	Success 
+///	- EXT_ERROR:	Error
+EXT_RES_CODE ext_analyze() {
+    int i, j, last;
+    MRPH *mrph_p,*mrph_p1;
+
+	if(FALSE==juman_sent()) return EXT_ANA_ERROR;
+	//	from print_best_path
+    j = 0;
+    last = p_buffer_num-1;
+    do {
+		last = p_buffer[last].path[0];
+		path_buffer[j] = last;
+		j++;
+	} while ( p_buffer[last].path[0] );
+	Dext.pos = i=j-1;
+	return EXT_SUCCESS;
+}
+
+///	Get result in mopheme buffer
+///	@param pnum_mrphs [out]Number of mopheme in buffer
+///	@return 
+///	- EXT_SUCCESS:	Put all morpheme.
+///	- EXT_WORD_BUFF_OVER:	Word buffer is not enough. Call more to get all morpheme.
+///	- EXT_MRPH_BUFF_OVER:	Morpheme buffer is not enough. Call more to get all morpheme.
+EXT_RES_CODE ext_get_result(int *pnum_mrphs) {
+	
+	char * word_pos;
+	size_t word_buf_rest;
+	int path_num;
+	MRPH *mrph_p;
+	EXT_MRPH_T *pitem;
+	
+	word_pos = Dext.word_buf;
+	word_buf_rest = Dext.word_buf_size;
+	word_pos[word_buf_rest-1] = 0;
+	*pnum_mrphs = 0;
+
+	while(Dext.pos>=0 && *pnum_mrphs < Dext.max_mrphs) {
+		path_num = path_buffer[Dext.pos];
+		if ((mrph_p = prepare_path_mrph(path_num, 0)) == NULL) continue;
+		pitem = Dext.mrphs_buf + *pnum_mrphs;
+		pitem->midasi1 = wordcopy(&word_pos, &word_buf_rest, midasi1);
+		if(NULL==pitem->midasi1) return EXT_WORD_BUFF_OVER;
+		pitem->yomi = wordcopy(&word_pos, &word_buf_rest, yomi);
+		if(NULL==pitem->yomi) return EXT_WORD_BUFF_OVER;
+		pitem->midasi2 = wordcopy(&word_pos, &word_buf_rest, midasi2);
+		if(NULL==pitem->midasi2) return EXT_WORD_BUFF_OVER;
+		pitem->hinsi = mrph_p->hinsi;
+		pitem->bunrui = mrph_p->bunrui;
+		pitem->katuyou1 = mrph_p->katuyou1;
+		pitem->katuyou2 = mrph_p->katuyou2;
+
+		(*pnum_mrphs)++;
+		Dext.pos--;
+	}
+	if(Dext.pos>=0) return EXT_MRPH_BUFF_OVER;
+	return EXT_SUCCESS;
+}
+
+static char * wordcopy(char **pword_pos, size_t *pword_buf_rest, const char * word) {
+	char * pwritten;
+	int len;
+	len = strlen(word);
+	if(len+1 >= *pword_buf_rest) return NULL;
+	pwritten = strcpy(*pword_pos, word);
+	(*pword_buf_rest) -= len+1;
+	(*pword_pos) += len+1;
+	return pwritten;
+}
+
+///	Get hinsi string.
+///	@param hinsi Index of hinsi.
+///	@return String of bunrui. if index is wrong, return null string.
+const char * ext_get_hinsi(int hinsi) {
+	return (Class[hinsi][0].id==NULL)? 
+		NullStr: (const char *)Class[hinsi][0].id;
+}
+
+///	Get all hinsi
+///	@param list [out]List of hinsi. It ranges from 1 to return num-1.
+///	@return Nunber of list items.
+int ext_get_all_hinsi(const char ** list) {
+	int i;
+	*list++ = NullStr;
+	for (i=1 ; Class[i][0].id!=NULL && i<=CLASSIFY_NO; i++) {
+		*list++ = Class[i][0].id;
+	}
+	return i;
+}
+
+///	Get bunrui string.
+///	@param hinsi Index of hinsi.
+///	@param bunrui Index of bunrui.
+///	@return String of bunrui. if index is wrong, return null string.
+const char * ext_get_bunrui(int hinsi, int bunrui) {
+	return (Class[hinsi][bunrui].id==NULL)? 
+		NullStr: (const char *)Class[hinsi][bunrui].id;
+}
+
+///	Get all bunrui
+///	@param hinsi Index of hinsi.
+///	@param list [out]List of bunrui. It ranges from 1 to return num-1.
+///	@return Nunber of list items.
+int ext_get_all_bunrui(int hinsi, const char ** list) {
+	int i;
+	*list++ = NullStr;
+	for (i=1 ; Class[hinsi][i].id!=NULL && i<=CLASSIFY_NO; i++) {
+		*list++ = Class[hinsi][i].id;
+	}
+	return i;
+}
+
+///	Get katuyou1 string.
+///	@param katuyou1 Index of katuyou1.
+///	@return String of katuyou1. if index is wrong, return null string.
+const char * ext_get_katuyou1(int katuyou1) {
+	return (Type[katuyou1].name==NULL)? 
+		NullStr: (const char *)Type[katuyou1].name;
+}
+
+///	Get all katuyou1
+///	@param list [out]List of katuyou1. It ranges from 1 to return num-1.
+///	@return Nunber of list items.
+int ext_get_all_katuyou1(const char ** list) {
+	int i;
+	*list++ = NullStr;
+	for (i=1 ; Type[i].name!=NULL && i<TYPE_NO; i++) {
+		*list++ = Type[i].name;
+	}
+	return i;
+}
+
+///	Get katuyou2 string.
+///	@param katuyou1 Index of katuyou1.
+///	@param katuyou2 Index of katuyou2.
+///	@return String of katuyou2. if index is wrong, return null string.
+const char * ext_get_katuyou2(int katuyou1, int katuyou2) {
+	return (Form[katuyou1][katuyou2].name==NULL)? 
+		NullStr: (const char *)Form[katuyou1][katuyou2].name;
+}
+
+///	Get all katuyou2
+///	@param katuyou2 Index of katuyou2.
+///	@param list [out]List of katuyou2. It ranges from 1 to return num-1.
+///	@return Nunber of list items.
+int ext_get_all_katuyou2(int katuyou1, const char ** list) {
+	int i;
+	*list++ = NullStr;
+	for (i=1 ; Form[katuyou1][i].name!=NULL && i<FORM_NO; i++) {
+		*list++ = Form[katuyou1][i].name;
+	}
+	return i;
+}
+
+///	Get posible max number of params.
+///	Those index ranges from 1 to return num-1. 
+void ext_get_maxidx(int *pmax_hinsi, int *pmax_bunrui, 
+	int *pmax_katuyou1, int *pmax_katuyou2) {
+	*pmax_hinsi = CLASSIFY_NO+1;
+	*pmax_bunrui = CLASSIFY_NO+1;
+	*pmax_katuyou1 = TYPE_NO;
+	*pmax_katuyou2 = FORM_NO;
+}
+
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/ext_api.h juman-7.01/lib/ext_api.h
--- B:/msys64/tmp/juman-7.01/lib/ext_api.h	Thu Jan  1 00:00:00 1970
+++ juman-7.01/lib/ext_api.h	Tue Oct 31 18:17:00 2017
@@ -0,0 +1,129 @@
+#ifndef EXT_API_H
+#define EXT_API_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define DEF_MAX_ITEMS	(1000)
+
+typedef struct ext_mrph_t {
+	const char * midasi1;
+	const char * yomi;
+	const char * midasi2;
+	int hinsi;
+	int bunrui;
+	int katuyou1;
+	int katuyou2;
+} EXT_MRPH_T;
+
+typedef enum ext_res_code {
+	EXT_SUCCESS = 0,
+	EXT_MRPH_BUFF_OVER,
+	EXT_WORD_BUFF_OVER,
+	EXT_ERROR = 100,
+	EXT_RC_ERROR,
+	EXT_MALLOC_ERROR,
+	EXT_FILE_NOT_EXISTS,
+	EXT_ANA_ERROR,
+} EXT_RES_CODE;
+
+///	Set encoding
+///	It must be called before ext_init.
+///	If specified wrong encoding name, error will occure in ext_init.
+/// @param s_encoding Comma separated string of input and output encoding.
+///	If comma does not exist, both input and output encoding considered this value.
+///	If NULL or null string, considered same as inner encoding and will not do encoding.
+extern void ext_set_encoding(const char *s_encoding);
+
+///	Initialize lib
+///	@param s_rcfile	Path to jumanrc
+///	@param word_buf_size Word buffer size. It is copied midasi1, yomi, and midasi2.
+///	@param max_mrphs Morpheme buffer size in number. 
+///	@return 
+///	- EXT_SUCCESS:	Success 
+///	- EXT_RC_ERROR:	Resource file error.
+///	- EXT_MALLOC_ERROR:	Cannot allocate memory.
+extern EXT_RES_CODE ext_init(const char *s_rcfile, size_t word_buf_size, int max_mrphs);
+
+///	Close extlib
+extern void ext_close();
+	
+///	Get input buffer to write.
+///	@param psize [out]Buffer size.
+///	@return Buffer address.
+extern char * ext_get_input_buff(size_t *psize);
+
+///	Get morpheme buffer to read.
+///	@return Buffer address.
+extern EXT_MRPH_T * ext_get_mrph_buff();
+
+///	Analyze with best path
+///	@return 
+///	- EXT_SUCCESS:	Success 
+///	- EXT_ERROR:	Error
+extern EXT_RES_CODE ext_analyze();
+
+///	Get result in mopheme buffer
+///	@param pnum_mrphs [out]Number of mopheme in buffer
+///	@return 
+///	- EXT_SUCCESS:	Put all morpheme.
+///	- EXT_WORD_BUFF_OVER:	Word buffer is not enough. Call more to get all morpheme.
+///	- EXT_MRPH_BUFF_OVER:	Morpheme buffer is not enough. Call more to get all morpheme.
+extern EXT_RES_CODE ext_get_result(int *pnum_mrphs);
+
+///	Get hinsi string.
+///	@param hinsi Index of hinsi.
+///	@return String of bunrui. if index is wrong, return null string.
+extern const char * ext_get_hinsi(int hinsi);
+
+///	Get all hinsi
+///	@param list [out]List of hinsi. It ranges from 1 to return num-1.
+///	@return Nunber of list items.
+extern int ext_get_all_hinsi(const char ** list);
+
+///	Get bunrui string.
+///	@param hinsi Index of hinsi.
+///	@param bunrui Index of bunrui.
+///	@return String of bunrui. if index is wrong, return null string.
+extern const char * ext_get_bunrui(int hinsi, int bunrui);
+
+///	Get all bunrui
+///	@param hinsi Index of hinsi.
+///	@param list [out]List of bunrui. It ranges from 1 to return num-1.
+///	@return Nunber of list items.
+extern int ext_get_all_bunrui(int hinsi, const char ** list);
+
+///	Get katuyou1 string.
+///	@param katuyou1 Index of katuyou1.
+///	@return String of katuyou1. if index is wrong, return null string.
+extern const char * ext_get_katuyou1(int katuyou1);
+
+///	Get all katuyou1
+///	@param list [out]List of katuyou1. It ranges from 1 to return num-1.
+///	@return Nunber of list items.
+extern int ext_get_all_katuyou1(const char ** list);
+
+///	Get katuyou2 string.
+///	@param katuyou1 Index of katuyou1.
+///	@param katuyou2 Index of katuyou2.
+///	@return String of katuyou2. if index is wrong, return null string.
+extern const char * ext_get_katuyou2(int katuyou1, int katuyou2);
+
+///	Get all katuyou2
+///	@param katuyou2 Index of katuyou2.
+///	@param list [out]List of katuyou2. It ranges from 1 to return num-1.
+///	@return Nunber of list items.
+extern int ext_get_all_katuyou2(int katuyou1, const char ** list);
+
+///	Get posible max number of params.
+///	Those index ranges from 1 to return num-1. 
+extern void ext_get_maxidx(int *pmax_hinsi, int *pmax_bunrui, 
+	int *pmax_katuyou1, int *pmax_katuyou2);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	//	EXT_API_H
+
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/iotool.c juman-7.01/lib/iotool.c
--- B:/msys64/tmp/juman-7.01/lib/iotool.c	Tue Oct 18 16:19:24 2011
+++ juman-7.01/lib/iotool.c	Wed Oct 25 17:30:02 2017
@@ -12,6 +12,14 @@
 
 #include	<juman.h>
 #define         DEF_GRAM_FILE           "文法ファイル"
+
+#ifdef _WIN32
+#ifdef RC_DEFAULT
+#undef RC_DEFAULT
+#define RC_DEFAULT "C:\\ProgramData\\juman\\jumanrc"
+#endif
+#endif
+
 /*
 ------------------------------------------------------------------------------
 	GLOBAL:
@@ -21,12 +29,15 @@
 
 extern char	*ProgName;
 FILE		*Jumanrc_Fileptr;
+extern char	    Jumanrc_Dir[FILENAME_MAX];
 extern char            Jumangram_Dirname[FILENAME_MAX];  /*k.n*/
 extern int             LineNoForError, LineNo;
 
 int Cha_errno = 0;
 FILE 		*Cha_stderr = NULL;
 
+static BOOL set_jumanrc_dir(const char * s_path);
+    
 /*
 ------------------------------------------------------------------------------
 	FUNCTION:
@@ -73,8 +84,10 @@ FILE *pathfopen(char *filename, char *mo
 {
      FILE	*fp;
 
-     strcpy(filename_path, path);
-     strcat(filename_path, filename);
+     if(!IS_ABS_PATH(filename)) {
+        strcpy(filename_path, path);
+        strcat(filename_path, filename);
+    }
 
      return (fp = fopen(filename_path, mode));
 }
@@ -218,11 +231,11 @@ void my_exit(int exit_code)
 ------------------------------------------------------------------------------
 */
 
-void error(int errno, char *msg, ...)
+void error(int err_no, char *msg, ...)
 {
      char *str;
      va_list ap;
-
+     
      if (Cha_stderr == NULL)
 	 Cha_stderr = stderr;
 
@@ -236,7 +249,7 @@ void error(int errno, char *msg, ...)
 
      va_end(ap);
 
-     my_exit(errno);
+     my_exit(err_no);
 }
 
 /*
@@ -246,7 +259,7 @@ void error(int errno, char *msg, ...)
 ------------------------------------------------------------------------------
 */
 
-void warning(int errno, char *msg, ...)
+void warning(int err_no, char *msg, ...)
 {
      char *str;
      va_list ap;
@@ -510,10 +523,12 @@ void set_jumanrc_fileptr(char *option_rc
 	$HOME/.jumanrc
 	→ rcfileがなくてもよい
     */
+    char * s_path = "";
 
     char *user_home_ptr, *getenv(), filename[FILENAME_MAX];
 
-    if (option_rcfile) {
+    if (option_rcfile!=NULL && option_rcfile[0]!=0) {
+    s_path = option_rcfile;
 	if ((Jumanrc_Fileptr = fopen(option_rcfile, "r")) == NULL) {
 	    fprintf(stderr, "not found <%s>.\n", option_rcfile);
 	    exit(0);
@@ -534,9 +549,11 @@ void set_jumanrc_fileptr(char *option_rc
 	else
 	    sprintf(filename, "%s/.jumanrc" , user_home_ptr);
 #endif
-	if (filename[0] == '\0' || (Jumanrc_Fileptr = fopen(filename, "r")) == NULL) {
+    s_path = filename;
+    if (filename[0] == '\0' || (Jumanrc_Fileptr = fopen(filename, "r")) == NULL) {
 	    if (look_rcdefault_p) {
 #ifdef RC_DEFAULT
+        s_path = RC_DEFAULT;
 		if ((Jumanrc_Fileptr = fopen(RC_DEFAULT ,"r")) == NULL) {
 		    if (exit_rc_notfound_p) {
 			fprintf(stderr, 
@@ -557,6 +574,13 @@ void set_jumanrc_fileptr(char *option_rc
 	    }
 	}
      }
+    //  Set Jumanrc_Dir
+    if(NULL!=Jumanrc_Fileptr) {
+        if(FALSE==set_jumanrc_dir(s_path)) {
+            fprintf(stderr, "Path to jumanrc is too long.\n");
+            exit(0);
+        }
+    }
 }
 
 /*
@@ -622,10 +646,8 @@ static char chasenrc_path[CHA_FILENAME_M
 ------------------------------------------------------------------------------
 */
 
-void cha_exit(status, format, a, b, c, d, e, f, g, h)
-    int status;
-    char *format, *a, *b, *c, *d, *e, *f, *g, *h;
-{
+void cha_exit(int status, const char *format, ...) {
+    va_list va;
     if (Cha_errno)
       return;
 
@@ -634,8 +656,11 @@ void cha_exit(status, format, a, b, c, d
 
     if (progpath)
       fprintf(Cha_stderr, "%s: ", progpath);
-    fprintf(Cha_stderr, format, a, b, c, d, e, f, g, h);
 
+    va_start(va, format);
+    vfprintf(Cha_stderr, format, va);
+	va_end(va);
+    
     if (status >= 0) {
 	fputc('\n', Cha_stderr);
 	if (Cha_stderr == stderr)
@@ -674,17 +699,45 @@ void cha_exit_file(status, format, a, b,
     }
 }
 
-void cha_perror(s)
-    char *s;
-{
+void cha_perror(const char *s) {
     cha_exit(-1, "");
     perror(s);
 }
 
-void cha_exit_perror(s)
-    char *s;
-{
+void cha_exit_perror(const char *s) {
     cha_perror(s);
     exit(1);
 }
 
+//  simplified set_jumanrc_fileptr
+BOOL set_jumanrc_fileptr_min(const char * option_rcfile) {
+	if ((Jumanrc_Fileptr = fopen(option_rcfile, "r")) == NULL) {
+        return FALSE;
+    }
+    return set_jumanrc_dir(option_rcfile);
+}
+
+//  Set jumanrc directory to global
+static BOOL set_jumanrc_dir(const char * s_path) {
+    int pos;
+    char *p_c;
+    char abs_path[FILENAME_MAX];
+    Jumanrc_Dir[0] = 0;
+    if( !IS_ABS_PATH(s_path)) {
+        getcwd(abs_path, sizeof(abs_path));
+        strncat(abs_path, "/", sizeof(abs_path));
+        strncat(abs_path, s_path, sizeof(abs_path));
+        abs_path[sizeof(abs_path)-1] = 0;
+        s_path = abs_path;
+    }
+    Jumanrc_Dir[sizeof(Jumanrc_Dir)-1] = 0;
+    strncpy(Jumanrc_Dir, s_path, sizeof(Jumanrc_Dir));
+    if(Jumanrc_Dir[sizeof(Jumanrc_Dir)-1]) {
+        return FALSE;
+    }
+    pos = strlen(Jumanrc_Dir)-1;
+    p_c = (char *)Jumanrc_Dir + pos;
+    for(; pos>0; pos--, p_c--) if(*p_c=='\\' || *p_c=='/') break;
+    *p_c = 0;
+    return TRUE;
+}
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/json_parse.c juman-7.01/lib/json_parse.c
--- B:/msys64/tmp/juman-7.01/lib/json_parse.c	Thu Jan  1 00:00:00 1970
+++ juman-7.01/lib/json_parse.c	Tue Oct 31 20:45:44 2017
@@ -0,0 +1,549 @@
+#include <string.h>
+#include <sys\stat.h>
+#include <stdlib.h>
+#include "json_parse.h"
+
+#define INIT_OBJ_SIZE	(8)
+#define is_space(ptr) (*(ptr)==' ' || *(ptr)=='\t' || *(ptr)=='\r' || *(ptr)=='\n')
+#define skip_space(ptr) {while(is_space(ptr)) (ptr)++;}
+#define skip_not_space(ptr) {while(!is_space(ptr) && *(ptr)!=0) (ptr)++;}
+
+static bool parse_val(JSON_T * json, JSON_VALUE_T * pval);
+
+static bool alloc_obj(JSON_TYPE_E type, JSON_OBJ_T * obj) {
+	size_t vals_size, keys_size;
+	char * buff;
+
+	if(obj->values==NULL) obj->allocd = INIT_OBJ_SIZE;
+	else obj->allocd *= 2;
+	vals_size = sizeof(JSON_VALUE_T) * obj->allocd;
+	keys_size = (type==JSON_OBJECT)? sizeof(char *) * obj->allocd: 0;
+	if(NULL==(buff = malloc(vals_size + keys_size))) return false;
+	if(obj->values!=NULL) {
+		memcpy(buff, obj->values, sizeof(JSON_VALUE_T) * obj->number);
+		if(keys_size) {
+			memcpy(buff + vals_size, obj->keys, sizeof(char *) * obj->number);
+		}
+		free(obj->values);
+	}
+	obj->values = (JSON_VALUE_T *)buff;
+	obj->keys = (char **)(buff + vals_size);
+	return true;
+}
+
+static void free_obj(JSON_OBJ_T * obj) {
+	int i;
+	JSON_VALUE_T * value;
+	JSON_TYPE_E type;
+	for(i=0, value=obj->values; i<obj->number; i++,value++) {
+		if(value->type==JSON_ARRAY || value->type==JSON_OBJECT) {
+			free_obj(&(value->v_obj));
+		}
+	}
+	free(obj->values);
+}
+
+static char * get_string(JSON_T * json) {
+	char * rep;
+	if(*(json->ptr)!='"') return NULL;
+	rep = ++(json->ptr);
+	while(*(json->ptr) && *(json->ptr)!='"') {
+		if(*(json->ptr)=='\\') (json->ptr)++;
+		(json->ptr)++;
+	}
+	if(*(json->ptr)!='"') return NULL;
+	*(json->ptr)++ = 0;
+	return rep;
+}
+
+static bool parse_object(JSON_T * json, JSON_VALUE_T * pval) {
+	JSON_OBJ_T * obj;
+	char ** pkey;
+	JSON_VALUE_T * pvalue;
+	char c_end;
+	bool b_result;
+
+	c_end = *(json->ptr)=='{'? '}': ']';
+	pval->type = *(json->ptr)=='{'? JSON_OBJECT: JSON_ARRAY;
+	obj = &(pval->v_obj);
+	obj->number = 0;
+	obj->allocd = 0;
+	obj->values = NULL;
+	obj->keys = NULL;
+	b_result = false;
+	(json->ptr)++;
+	while(*(json->ptr)) {
+		if(obj->number==obj->allocd) alloc_obj(pval->type, obj);		
+		if(pval->type==JSON_OBJECT) {
+			pkey = obj->keys + obj->number;
+			skip_space(json->ptr);
+			if(NULL==(*pkey = get_string(json))) break;
+			skip_space(json->ptr);
+			if(*(json->ptr)!=':') break;
+			(json->ptr)++;
+		}
+		pvalue= obj->values + obj->number;
+		skip_space(json->ptr);
+		if(false==(parse_val(json, pvalue))) break;
+		(obj->number)++;
+		skip_space(json->ptr);
+		if(*(json->ptr)==c_end) {
+			b_result = true;
+			(json->ptr)++;
+			break;
+		};
+		if(*(json->ptr)!=',') break;
+		(json->ptr)++;
+	}
+	if(!b_result) {
+		free_obj(obj);
+		return false;
+	}
+	return true;
+}
+
+static bool parse_str(JSON_T * json, JSON_VALUE_T * pval) {
+	pval->type = JSON_STRING;
+	if(NULL==(pval->v_string = get_string(json))) return false;
+	return true;
+}
+
+static bool parse_others(JSON_T * json, JSON_VALUE_T * pval) {
+	char * str;
+	char * ep;
+	str = json->ptr;
+	skip_not_space(json->ptr);
+	if(*(json->ptr)) *(json->ptr)++ = 0;
+	if(0==strcmp("null", str)) {
+		pval->type = JSON_NULL;
+	} else if(0==strcmp("true", str)) {
+		pval->type = JSON_BOOL;
+		pval->v_bool = true;
+	} else if(0==strcmp("false", str)) {
+		pval->type = JSON_BOOL;
+		pval->v_bool = false;
+	} else {
+		pval->v_number = strtod(str, &ep);
+		if(*ep) return false;
+	}
+	return true;
+}
+
+static bool parse_val(JSON_T * json, JSON_VALUE_T * pval) {
+	skip_space(json->ptr);
+	if(*(json->ptr)==0) return false;
+	switch(*(json->ptr)) {
+		case '{':
+		case '[':
+			return parse_object(json, pval);
+		case '"':
+			return parse_str(json, pval);
+		default:
+			return parse_others(json, pval);
+	}
+}
+
+static const JSON_VALUE_T * parse(JSON_T * json) {
+	json->ptr = json->buff;
+	if(false==parse_val(json, &(json->value))) return NULL;
+	return &(json->value);
+}
+
+static bool get_buff(JSON_T * json, size_t length) {
+	size_t size;
+	char * buff;
+	size = length + 1;
+	if(NULL==(buff=malloc(size))) return false;
+	json->buff = buff;
+	return true;
+}
+
+const JSON_VALUE_T * json_parse_file(JSON_T * json, const char * fn) {
+	struct stat status;
+	size_t length, written;
+	FILE * fp;
+	if(0!=stat(fn, &status)) return NULL;
+	if(false==get_buff(json, status.st_size)) return NULL;
+	if(NULL==(fp=fopen(fn, "rb"))) return NULL;
+	written = fread(json->buff, 1, status.st_size, fp);
+	fclose(fp);
+	*(json->buff + written) = 0;
+	return parse(json);
+}
+
+const JSON_VALUE_T * json_parse_str(JSON_T * json, const char * str) {
+	size_t length;
+	char * buff;
+	length = strlen(str);
+	if(false==get_buff(json, length)) return NULL;
+	strncpy(json->buff, str, length+1);
+	return parse(json);
+}
+
+JSON_T * json_open() {
+	JSON_T * json;
+	
+	if(NULL==(json = malloc(sizeof(JSON_T)))) return NULL;
+	json->buff = NULL;
+	json->ptr = NULL;
+	json->value.type = JSON_NULL;
+	return json;
+}
+
+void json_close(JSON_T * json) {
+	if(json->value.type==JSON_ARRAY || json->value.type==JSON_OBJECT) {
+		free_obj(&(json->value.v_obj));
+	}
+	if(json->buff!=NULL) free(json->buff);
+	free(json);
+}
+
+bool json_is_null(const JSON_VALUE_T * value) {
+	return (value->type==JSON_NULL)? true: false;
+}
+
+bool json_get_bool(const JSON_VALUE_T * value, bool * pval) {
+	if(value->type!=JSON_BOOL) return false;
+	*pval = value->v_bool;
+	return true;
+}
+
+bool json_get_int(const JSON_VALUE_T * value, int * pval) {
+	if(value->type!=JSON_NUMBER) return false;
+	*pval = (int)(value->v_number);
+	return true;
+}
+
+bool json_get_double(const JSON_VALUE_T * value, double * pval) {
+	if(value->type!=JSON_NUMBER) return false;
+	*pval = value->v_number;
+	return true;
+}
+
+bool json_get_str(const JSON_VALUE_T * value, const char ** pval) {
+	if(value->type!=JSON_STRING) return false;
+	*pval = value->v_string;
+	return true;
+}
+	
+const char * json_get_key(const JSON_VALUE_T * value, int idx) {
+	const JSON_OBJ_T * obj;
+	if(value->type!=JSON_OBJECT) return false;
+	obj = &(value->v_obj);
+	if(idx<0 || obj->number<=idx) return NULL;
+	return *(obj->keys + idx);
+}
+
+JSON_VALUE_T * json_search(const JSON_VALUE_T * value, const char * key) {
+	int i;
+	char ** keys;
+	const JSON_OBJ_T * obj;
+	if(value->type!=JSON_OBJECT) return false;
+	obj = &(value->v_obj);
+	keys = obj->keys;
+	for(i=0; i<obj->number; i++) {
+		if(0==strcmp(key, *(keys + i))) {
+			return obj->values + i;
+		}
+	}
+	return NULL;
+}
+
+JSON_VALUE_T * json_get_item(const JSON_VALUE_T * value, int idx) {
+	if(value->type!=JSON_OBJECT && value->type!=JSON_ARRAY) return NULL;
+	if(idx<0 || value->v_obj.number<=idx) return NULL;
+	return value->v_obj.values + idx;
+}
+
+typedef struct print_info_t {
+	FILE * fp;
+	int level;
+	bool b_symbole;
+	int indent;
+	bool b_shallow;
+} PRINT_INFO_T;
+
+#define IS_DEEP(pinfo)	((pinfo)->level >0 && (pinfo)->indent + 1 > (pinfo)->level)
+#define PRINT_STR(pinfo, str)	fprintf((pinfo)->fp, (pinfo)->b_symbole? "\"%s\"": "%s", (str))
+#define PRINTF(pinfo, ...)  fprintf((pinfo)->fp, __VA_ARGS__)
+#define PRINT_SPACE(pinfo, b_inline) ((b_inline)? fprintf((pinfo)->fp, " "): print_indent(pinfo))
+#define TO_INLINE(obj) ((obj)->number==0 \
+	|| ((obj)->number==1 \
+		&& (obj)->values->type!=JSON_ARRAY \
+		&& (obj)->values->type!=JSON_OBJECT))
+
+static size_t get_str(const JSON_VALUE_T * value, PRINT_INFO_T * pinfo, char * str, size_t size) {
+	int written = 0;
+	switch(value->type) {
+		case JSON_NULL:
+			written = snprintf(str, size, "null");
+			break;
+		case JSON_BOOL:
+			written = snprintf(str, size, (value->v_bool)? "true": "false");
+			break;
+		case JSON_NUMBER:
+			written = snprintf(str, size, "%lf", value->v_number);
+			break;
+		case JSON_STRING:
+			written = snprintf(str, size, pinfo->b_symbole? "\"%s\"": "%s", value->v_string);
+			break;
+	}
+	if(written >= size) return 0; 
+	return written; 
+}
+
+static void print_val(const JSON_VALUE_T * value, PRINT_INFO_T * pinfo);
+
+static int print_indent(PRINT_INFO_T * pinfo) {
+	int i, indent;
+	const char * space = "  "; 
+	PRINTF(pinfo, "\n");
+	indent = pinfo->indent;
+	if(pinfo->b_shallow && indent) indent--;
+	for(i=0; i<indent; i++) {
+		PRINTF(pinfo, space);
+	}
+	return indent * 2;
+}
+	
+static bool has_obj(const JSON_OBJ_T * obj) {
+	const JSON_VALUE_T * pvalue;
+	int i;
+	pvalue = obj->values;
+	for(i=0; i<obj->number; i++,pvalue++) {
+		if(pvalue->type==JSON_ARRAY || pvalue->type==JSON_OBJECT) {
+			return true;
+		} 
+	}
+	return false;
+}
+
+static void print_obj_compact(JSON_TYPE_E type, const JSON_OBJ_T * obj, PRINT_INFO_T * pinfo) {
+	int i, x;
+	char ** pkey;
+	JSON_VALUE_T * pvalue;
+	char buff[78];
+	char * wptr;
+	size_t written, remain;
+
+	pkey = obj->keys;
+	pvalue = obj->values;
+	x = print_indent(pinfo);
+	for(i=0; i<obj->number; i++,pkey++,pvalue++) {
+		if(i>0) {
+			PRINTF(pinfo, ", ");
+			x+=2;
+		}
+		wptr = buff;
+		remain = sizeof(buff);
+		if(type==JSON_OBJECT) {
+			written = snprintf(wptr, remain, pinfo->b_symbole? "\"%s\"": "%s", *pkey);
+			if(written < remain-5) {
+				wptr += written;
+				strncpy(wptr, " : ", remain);
+				wptr += 3;
+				remain -= (written + 3);
+			} else {
+				remain = 0;
+			}
+		}
+		if(remain>0) {
+			written = get_str(pvalue, pinfo, wptr, remain);
+			if(written==0) remain = 0;
+			else remain -= written;
+		}
+		if(remain) {
+			if(x >= remain) {
+				x = print_indent(pinfo);
+			} else {
+				x += sizeof(buff) - remain;
+			}
+			PRINTF(pinfo, buff);
+		} else {
+			print_indent(pinfo);
+			if(type==JSON_OBJECT) {
+				PRINT_STR(pinfo, *pkey);			
+				PRINTF(pinfo, " : ");
+			}
+			print_val(pvalue, pinfo);
+			x = sizeof(buff) + 1;
+		}
+	}
+}
+
+static void print_obj_full(JSON_TYPE_E type, const JSON_OBJ_T * obj, PRINT_INFO_T * pinfo) {
+	int i, j;
+	char ** pkey;
+	JSON_VALUE_T * pvalue;
+
+	pkey = obj->keys;
+	pvalue = obj->values;
+	j = 0;
+	for(i=0; i<obj->number; i++,pkey++,pvalue++) {
+		if((pvalue->type==JSON_ARRAY || pvalue->type==JSON_OBJECT)
+			&& IS_DEEP(pinfo)) {
+			continue;
+		}
+		if(j>0) PRINTF(pinfo, ",");
+		j++;
+		PRINT_SPACE(pinfo, TO_INLINE(obj));
+		if(type==JSON_OBJECT) {
+			PRINT_STR(pinfo, *pkey);			
+			PRINTF(pinfo, " : ");
+		}
+		print_val(pvalue, pinfo);
+	}
+}
+
+static void print_obj(JSON_TYPE_E type, const JSON_OBJ_T * obj, PRINT_INFO_T * pinfo) {
+	const char * s_brackets;
+
+	s_brackets = (type==JSON_OBJECT)? "{\0}": "[\0]";
+	if(pinfo->b_symbole) PRINTF(pinfo, s_brackets);
+	pinfo->indent++;
+	if(!has_obj(obj) && !TO_INLINE(obj)) {
+		print_obj_compact(type, obj, pinfo);
+	} else {
+		print_obj_full(type, obj, pinfo);
+	}
+	pinfo->indent--;
+	if(pinfo->b_symbole) {
+		PRINT_SPACE(pinfo, TO_INLINE(obj));
+		PRINTF(pinfo, s_brackets+2);
+	}
+}
+
+static void print_val(const JSON_VALUE_T * value, PRINT_INFO_T * pinfo) {
+	char buff[81];
+	switch(value->type) {
+		case JSON_NULL:
+		case JSON_BOOL:
+		case JSON_NUMBER:
+			get_str(value, pinfo, buff, sizeof(buff));
+			PRINTF(pinfo, buff); 
+			break;
+		case JSON_STRING:
+			PRINT_STR(pinfo, value->v_string);
+			break;
+		case JSON_ARRAY:
+		case JSON_OBJECT:
+			print_obj(value->type, &(value->v_obj), pinfo);
+			break;
+	}
+}
+
+void json_fprint(const JSON_VALUE_T * value, FILE * fp, int level, bool b_symbole) {
+	PRINT_INFO_T info;
+	if(fp==NULL) fp = stdout;
+	info.fp = fp;
+	info.level = level;
+	info.b_symbole = b_symbole;
+	info.indent = 0;
+	info.b_shallow = (!info.b_symbole && 
+		(value->type==JSON_ARRAY || value->type==JSON_OBJECT))
+		? true: false;
+	print_val(value, &info);
+	fprintf(fp, "\n");
+}
+
+//	for JUMAN
+const char const * FLAG_STR_L[] = {
+	"remove_flags",
+	"correct_cyouon",
+	"unify_hyphendash",
+	"add_hyphen_minus",
+	"remove_ascii",
+	"add_ascii",
+	"check_form",
+	NULL
+};
+
+typedef struct dici_t {
+	JSON_T * json;
+	const JSON_VALUE_T * root;
+	unsigned long flags;
+} DICI_T;
+
+DICI_T DICI;
+
+static void dici_set_flags() {
+	int i, j;
+	const JSON_VALUE_T * flags;
+	const JSON_VALUE_T * flag;
+	const char * s_flag;
+	if(NULL==(flags = json_search(DICI.root, "flags"))) return;
+	for(i=0; NULL!=(flag=json_get_item(flags, i)); i++) {
+		if(json_get_str(flag, &s_flag)) {
+			for(j=0; FLAG_STR_L[j]!=NULL; j++) {
+				if(0==strcmp(s_flag, FLAG_STR_L[j])) {
+					DICI.flags |= 1<<j;
+					break;
+				}
+			}
+		}
+	}
+}
+
+bool dici_set_dir(const char * s_dir) {
+	char path[1024];
+
+	DICI.json = NULL;
+	DICI.root = NULL;
+	DICI.flags = 0;
+
+	path[sizeof(path)-1] = 0;
+	strncpy(path, s_dir, sizeof(path));
+	strncat(path, "/version.json", sizeof(path));
+	if(path[sizeof(path)-1]) return false;
+	if(NULL==(DICI.json = json_open())) return false;
+	if(NULL==(DICI.root = json_parse_file(DICI.json, path))) return false;
+	dici_set_flags();
+}
+
+bool dici_has_flag(unsigned int flag) {
+	return (DICI.flags & flag)? true: false;
+}
+
+static void dici_print_head(FILE * fp) {
+	char str[128];
+	const JSON_VALUE_T * val;
+	const char * sval;
+	val = DICI.root;
+	str[0] = 0;
+	if(NULL!=(val = json_search(DICI.root, "package-name"))) {
+		if(json_get_str(val, &sval)) strncat(str, sval, sizeof(str));
+	}
+	if(NULL!=(val = json_search(DICI.root, "package-version"))) {
+		if(json_get_str(val, &sval)) {
+			strncat(str, " ", sizeof(str));
+			strncat(str, sval, sizeof(str));
+		}
+	}
+	if(NULL!=(val = json_search(DICI.root, "version-date"))) {
+		if(json_get_str(val, &sval)) {
+			strncat(str, " ", sizeof(str));
+			strncat(str, sval, sizeof(str));
+		}
+	}
+	str[sizeof(str)-1] = 0;
+	fprintf(fp, str);
+}
+
+void dici_print(FILE * fp, int detail) {
+	if(NULL==fp) fp = stdout;
+	if(NULL==DICI.root) {
+		fprintf(fp, "No version.json\n");
+		return;
+	}
+	switch(detail) {
+		case 0:
+		dici_print_head(fp);
+		break;
+		case 1:
+		json_fprint(DICI.root, fp, 3, false);
+		break;
+		default:
+		json_fprint(DICI.root, fp, 0, false);
+		break;
+	}
+}
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/json_parse.h juman-7.01/lib/json_parse.h
--- B:/msys64/tmp/juman-7.01/lib/json_parse.h	Thu Jan  1 00:00:00 1970
+++ juman-7.01/lib/json_parse.h	Tue Oct 31 19:40:55 2017
@@ -0,0 +1,161 @@
+#ifndef JSON_PARSE_H
+#define JSON_PARSE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdbool.h>
+
+typedef enum json_type_e {
+	JSON_NULL,
+	JSON_BOOL,
+	JSON_STRING,
+	JSON_NUMBER,
+	JSON_ARRAY,
+	JSON_OBJECT
+} JSON_TYPE_E;
+
+struct json_value_t;
+
+typedef struct json_obj_t {
+	int number;
+	struct json_value_t * values;
+	char ** keys;
+	size_t allocd;
+} JSON_OBJ_T;
+
+typedef struct json_value_t {
+	JSON_TYPE_E type;
+	union {
+		bool v_bool;
+		char * v_string;
+		double v_number;
+		struct json_obj_t v_obj;
+	};
+} JSON_VALUE_T;
+
+typedef struct json_t {
+	char * buff;			///<	buffer
+	char * ptr;				///<	read pointer
+	JSON_VALUE_T value;		///<	root.
+} JSON_T;
+
+///	Open json object.
+///	@return the object, or NULL when fail.
+extern JSON_T * json_open();
+
+///	Close JSON object.
+///	@return json object.
+extern void json_close(JSON_T * json);
+
+///	Parse json file
+///	@param json json object.
+///	@param fn	Path to input file.
+///	@return parsed valse, or NULL when fail.
+extern const JSON_VALUE_T * json_parse_file(JSON_T * json, const char * fn);
+
+///	Parse json string
+///	@param json json object.
+///	@param str	String to parse.
+///	@return parsed valse, or NULL when fail.
+extern const JSON_VALUE_T * json_parse_str(JSON_T * json, const char * str);
+
+///	Is null?
+///	@param value Value
+///	@return true when null, otherwise false.
+extern bool json_is_null(const JSON_VALUE_T * value);
+
+///	Get bool value.
+///	@param value Value
+///	@param pval [out]bool value.
+///	@return true if the type is bool, otherwise false.
+extern bool json_get_bool(const JSON_VALUE_T * value, bool * pval);
+
+///	Get floored int value.
+///	@param value Value
+///	@param pval [out]int value.
+///	@return true if the type is number, otherwise false.
+extern bool json_get_int(const JSON_VALUE_T * value, int * pval);
+
+///	Get double value.
+///	@param value Value
+///	@param pval [out]double value.
+///	@return true if the type is number, otherwise false.
+extern bool json_get_double(const JSON_VALUE_T * value, double * pval);
+
+///	Get string value.
+///	@param value Value
+///	@param pval [out]string value.
+///	@return true if the type is string, otherwise false.
+extern bool json_get_str(const JSON_VALUE_T * value, const char ** pval);
+
+///	Get array value
+///	@param value Value
+///	@param pval [out]array value.
+///	@return true if the type is array, otherwise false.
+// extern bool json_get_array(JSON_VALUE_T * value, JSON_OBJ_T ** pval);
+
+///	Get object value
+///	@param object Value
+///	@param pval [out]object value.
+///	@return true if the type is object, otherwise false.
+// extern bool json_get_object(JSON_VALUE_T * value, JSON_OBJ_T ** pval);
+
+///	Get key of object.
+///	@param value Value
+///	@param idx Index.
+///	@return String of key, or NULL if type or idx is wrong.
+extern const char * json_get_key(const JSON_VALUE_T * value, int idx);
+
+///	Gat value from object.
+///	@param value Value
+///	@param key Key
+///	@return Value or NULL if type or key is wrong.
+extern JSON_VALUE_T * json_search(const JSON_VALUE_T * value, const char * key);
+
+///	Get value from array.
+///	@param value Value
+///	@param idx Index.
+///	@return Value or NULL if type or idx is wrong.
+extern JSON_VALUE_T * json_get_item(const JSON_VALUE_T * value, int idx);
+
+///	Print json data.
+///	@param value Value
+///	@param fp File struct pointer.
+///	@param value Value
+///	@param level Nesting level to print. if 0, print all.
+///	@param b_symbole if false, '"{}[],' is not print.
+extern void json_fprint(const JSON_VALUE_T * value, FILE * fp, int level, bool b_symbole);
+
+///	for JUMAN.
+
+#define DICF_REMOVE_FLAGS		0x0001
+#define DICF_CORRECT_CYOUON		0x0002
+#define DICF_UNIFY_HYPHENDASH	0x0004
+#define DICF_ADD_HYPHEN_MINUS	0x0008
+#define DICF_REMOVE_ASCII		0x0010
+#define DICF_ADD_ASCII			0x0020
+#define DICF_CHECK_FORM			0x0040
+
+///	Set dic or grammer directory
+///	@param s_dir Path to directory
+///	@return true as success or false.
+extern bool dici_set_dir(const char * s_dir);
+
+///	Test the dictionary has the flag
+///	@param flag flag to test. eg. DICF_UNIFY_HYPHENDASH.
+///	@return true as it has or false.
+extern bool dici_has_flag(unsigned int flag);
+
+///	Print information of the dictionary.
+///	@param fp file struct pointer.
+///	@param detail Print detail level. 0-2 
+extern void dici_print(FILE * fp, int detail);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //	JSON_PARSE_H
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/juman.h juman-7.01/lib/juman.h
--- B:/msys64/tmp/juman-7.01/lib/juman.h	Mon Dec 15 09:47:28 2014
+++ juman-7.01/lib/juman.h	Wed Oct 25 17:41:28 2017
@@ -423,7 +423,7 @@ void	getpath(char *cur_path, char *juman
 void	*my_alloc(int n);
 void	*my_realloc(void *ptr, int n);
 void	my_exit(int exit_code);
-void	error(int errno, char *msg, ...);
+void	error(int err_no, char *msg, ...);
 char	lower(char c);
 char	upper(char c);
 int 	my_strlen(U_CHAR *s);
@@ -438,6 +438,14 @@ void	ls(FILE *fp, char *p, char *f);
 void	print_current_time(FILE *fp);
 void	print_execute_time(FILE *fp, int dt, float dp);
 
+void warning(int err_no, char *msg, ...);
+void set_jumanrc_fileptr(char *option_rcfile, int look_rcdefault_p, int exit_rc_notfound_p);
+void set_jumangram_dirname();
+int check_filesize(FILE *fp);
+void cha_exit(int status, const char *format, ...);
+void cha_perror(const char *s);
+
+
 /* lisp.c */
 int	s_feof(FILE *fp);
 int	s_feof_comment(FILE *fp);
@@ -462,6 +470,8 @@ CELL	*_s_print_cdr(FILE *fp, CELL *cell)
 void	*lisp_alloc(int n);
 void 	lisp_alloc_push(void);
 void 	lisp_alloc_pop(void);
+void set_cha_getc();
+void unset_cha_getc();
 
 /* grammar.c */
 void	error_in_grammar(int n, int line_no);
@@ -489,6 +499,11 @@ void read_matrix(FILE *fp);
 int check_matrix(int postcon, int precon);
 int check_matrix_left(int precon);
 int check_matrix_right(int postcon);
+//  getid.c
+extern int get_hinsi_id(U_CHAR *x);
+extern int get_bunrui_id(U_CHAR *x, int hinsi);
+extern int get_type_id(U_CHAR *x);
+extern int get_form_id(U_CHAR *x, int type);
 
 /* zentohan.c */
 unsigned char	*zentohan(unsigned char *str1);
@@ -497,3 +512,29 @@ unsigned char	*hantozen(unsigned char *s
 /* for edr-dic */
 void check_edrtable(MRPH *mrph_p, CELL *x);
 
+//  for convert encoding.
+extern void set_encoding_opt(const char * s_encoding);
+extern char * get_input_buff(size_t *psize);
+extern void enc_fprintf(FILE * stream, const char * format, ...);
+
+#ifdef _WIN32
+#ifdef GetPrivateProfileString
+#undef GetPrivateProfileString
+#endif
+
+#define GetPrivateProfileString( lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName ) { \
+	if( strcmp("C:\\juman\\dic", lpDefault)==0 ) { \
+		int pos; char *p_c; \
+		GetModuleFileName( NULL, lpReturnedString, nSize); \
+		pos = strlen(lpReturnedString)-1; \
+		p_c = (char *)lpReturnedString + pos; \
+		for(; pos>0; pos--, p_c--) if(*p_c=='\\' || *p_c=='/') break; \
+		*p_c = 0; \
+	} else { \
+		*(char *)lpReturnedString = 0; \
+	} \
+}
+#endif
+
+//  s_path is absolute path?
+#define IS_ABS_PATH(s_path) ( *(s_path)=='/' || *(s_path)=='\\' || *(s_path+1)==':')
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/juman_lib.c juman-7.01/lib/juman_lib.c
--- B:/msys64/tmp/juman-7.01/lib/juman_lib.c	Mon Dec 15 09:48:31 2014
+++ juman-7.01/lib/juman_lib.c	Tue Oct 31 17:57:15 2017
@@ -90,8 +90,11 @@
 #include <config.h>
 #endif
 
+#include <sys/stat.h>
 #include	<juman.h>
 #include	<const.h>
+#include	"encoder.h"
+#include	"json_parse.h"
 
 /*
 ------------------------------------------------------------------------------
@@ -140,11 +143,11 @@ DIC_FILES               DicFile;
 
 COST_OMOMI       	cost_omomi;    
 char             	Jumangram_Dirname[FILENAME_MAX]; 
-extern FILE		*Jumanrc_Fileptr;
 int              	LineNo;
 int     		LineNoForError;       /* k.n */
 
 char			pat_buffer[50000];
+char	    Jumanrc_Dir[FILENAME_MAX];
 
 /*
 ------------------------------------------------------------------------------
@@ -189,6 +192,7 @@ int             prolong_ng_bunrui4_1, pr
 int             jiritsu_num;
 int             p_buffer_num;
 CONNECT_COST	connect_cache[CONNECT_MATRIX_MAX];
+char	encoding_Opt[ENC_NAME_LEN * 2];
 
 /* MRPH_BUFFER_MAX の制限を撤廃，動的にメモリ確保 */
 int		 mrph_buffer_max = 0;
@@ -209,6 +213,8 @@ U_CHAR		yomi[MIDASI_MAX];    /* 活用
 extern COST_OMOMI       cost_omomi;     /*k.n*/
 extern char             Jumangram_Dirname[FILENAME_MAX];  /*k.n*/
 
+extern char	    *Jumanrc_FilePath;
+ENCODER_T *	p_encoder = NULL;
 /*
 ------------------------------------------------------------------------------
 	prototype definition of functions       >>> changed by T.Nakamura <<<
@@ -257,6 +263,11 @@ int	pos_right_process(int position);
 int	check_connect(int pos_start, int m_num, char opt);
 int	juman_sent(void);
 
+int utf8_bytes(unsigned char *ucp);
+
+static BOOL resolve_path(char *path);
+#define fprintf enc_fprintf
+
 /*
 ------------------------------------------------------------------------------
 	PROCEDURE: <changeDictionary>          >>> changed by T.Nakamura <<<
@@ -303,7 +314,7 @@ int push_dic_file_for_win(char *dic_file
 
 BOOL juman_init_rc(FILE *fp)
 {
-    int  num, win32_decided = 0;
+    int  num;
     char dic_file_name[BUFSIZE], full_file_name[BUFSIZE];
     CELL *cell1, *cell2;
     
@@ -315,55 +326,18 @@ BOOL juman_init_rc(FILE *fp)
     cost_omomi.rensetsu = RENSETSU_WEIGHT_DEFAULT * MRPH_DEFAULT_WEIGHT;
     cost_omomi.cost_haba = COST_WIDTH_DEFAULT * MRPH_DEFAULT_WEIGHT;
 
-    /* 
-     *  MS Windows は辞書のパスを,juman.ini から取得する (辞書Dir も1つのみ (やや手抜))
-     *  しかも gramfile == dicfile
-     *  Changed by Taku Kudoh (taku@pine.kuee.kyoto-u.ac.jp)
-     */
-#ifdef _WIN32
-    /* 文法ファイル */
-    num = 0;
-#ifdef WIN_AZURE
-    GetPrivateProfileString("juman","dicfile",WIN_AZURE_DICFILE_DEFAULT,Jumangram_Dirname,sizeof(Jumangram_Dirname),"juman.ini");
-#else
-    GetPrivateProfileString("juman","dicfile","",Jumangram_Dirname,sizeof(Jumangram_Dirname),"juman.ini");
-#endif
-    if (Jumangram_Dirname[0]) {
-	grammar(NULL);
-	katuyou(NULL);
-	connect_table(NULL);
-	connect_matrix(NULL);
-
-	/* 辞書ファイル */
-#ifdef WIN_AZURE
-	/* use dic, autodic and wikipediadic for Azure */
-	GetPrivateProfileString("juman","dicfile",WIN_AZURE_DICFILE_DEFAULT,dic_file_name,sizeof(dic_file_name),"juman.ini");
-	push_dic_file_for_win(dic_file_name, num++);
-	GetPrivateProfileString("juman","autodicfile",WIN_AZURE_AUTODICFILE_DEFAULT,dic_file_name,sizeof(dic_file_name),"juman.ini");
-	push_dic_file_for_win(dic_file_name, num++);
-	GetPrivateProfileString("juman","wikipediadicfile",WIN_AZURE_WIKIPEDIADICFILE_DEFAULT,dic_file_name,sizeof(dic_file_name),"juman.ini");
-	push_dic_file_for_win(dic_file_name, num++);
-#else
-	GetPrivateProfileString("juman","dicfile","",dic_file_name,sizeof(dic_file_name),"juman.ini");
-	push_dic_file_for_win(dic_file_name, num++);
-#endif
-	DicFile.number = num;
-	changeDictionary(0);
-	win32_decided = 1;
-    }
-    /* juman.iniが利用できなければ、jumanrcから読む */
-#endif
-    
+	//	Remove all of reading from .ini for Windows.
     while (!s_feof(fp)) { 
 	LineNoForError = LineNo ;
 	cell1 = s_read(fp);
 
 	/* 文法ファイル */
-	if (!win32_decided && !strcmp(DEF_GRAM_FILE, _Atom(car(cell1)))) {
+	if (!strcmp(DEF_GRAM_FILE, _Atom(car(cell1)))) {
 	    if (!Atomp(cell2 = car(cdr(cell1)))) {
 		return FALSE;
 	    } else {
 		strcpy(Jumangram_Dirname , _Atom(cell2));
+		if( FALSE==resolve_path(Jumangram_Dirname) ) return FALSE;
 		grammar(NULL);
 		katuyou(NULL);
 		connect_table(NULL);
@@ -372,7 +346,7 @@ BOOL juman_init_rc(FILE *fp)
 	}
 	  
 	/* 辞書ファイル */
-	else if (!win32_decided && !strcmp(DEF_DIC_FILE, _Atom(car(cell1)))) {
+	else if (!strcmp(DEF_DIC_FILE, _Atom(car(cell1)))) {
 	    cell2 = cdr(cell1) ;
 	    for(num = 0 ; ; num++) {
 		if( Null(car(cell2)) )  break;
@@ -383,6 +357,7 @@ BOOL juman_init_rc(FILE *fp)
 		    error(ConfigError, "Too many dictionary files.", EOA);
 		else {
 		    strcpy(dic_file_name, _Atom(car(cell2)));
+			if( FALSE==resolve_path(dic_file_name) ) return FALSE;
 		    if ((endchar(dic_file_name)) != '/')
 			strcat(dic_file_name, "/");
 		    cell2 = cdr(cell2);
@@ -437,7 +412,20 @@ BOOL juman_init_rc(FILE *fp)
 	/* 未定義語コスト (3.4以降不要)
 	else if (!strcmp("未定義語品詞", _Atom(car(cell1))));
 	*/
-    }
+	}
+
+	if(NULL==(p_encoder = encoder_new(String, LENMAX, NULL, BUFSIZE))) {
+		fprintf(stderr, "Cannot open encoder.\n");
+		return FALSE;
+	} else {
+		char *s_inner_encoding = "UTF-8";
+		if(DEF_GRAM_FILE[0]==0x95) s_inner_encoding = "SHIFT_JIS";
+		if(!encoder_set_encoding(p_encoder, s_inner_encoding, encoding_Opt)) {
+			encoder_delete(p_encoder);
+			return FALSE;
+		}
+	}
+	dici_set_dir(Jumangram_Dirname);
     return TRUE;
 }
 
@@ -518,7 +506,9 @@ BOOL juman_close(void)
 
   free(rensetu_tbl);
   free(rensetu_mtr);
-
+  encoder_delete(p_encoder);
+  p_encoder = NULL;
+  
   return TRUE;
 }
 
@@ -2397,6 +2387,7 @@ int juman_sent(void)
 	process_buffer_max += BUFFER_BLOCK_SIZE;
     }
 
+	encoder_convert(p_encoder, ENC_IN);
     length = strlen(String);
 
     if (length == 0) return FALSE;	/* 空行はスキップ */
@@ -2549,3 +2540,40 @@ int juman_sent(void)
 
     return TRUE;
 }
+
+static BOOL resolve_path(char *path) {
+	char rcdir[FILENAME_MAX];	//	 < BUFFSIZE(1025)
+	struct stat status;
+	if( !IS_ABS_PATH(path) ) {
+		rcdir[sizeof(rcdir)-1] = 0;
+		strncpy(rcdir, Jumanrc_Dir, sizeof(rcdir));
+		strncat(rcdir, "/", sizeof(rcdir));
+		strncat(rcdir, path, sizeof(rcdir));
+		if(rcdir[sizeof(rcdir)-1]) {
+			fprintf(stderr, "The path is too long.(%s)\n", path);
+			return FALSE;
+		}
+		strcpy(path, rcdir);
+	}
+	if(stat(path, &status)) {
+		fprintf(stderr, "Cannot get file status(%s).\n", path);
+		return FALSE;
+	}
+	return TRUE;
+}
+
+void set_encoding_opt(const char * s_encoding) {
+	strncpy(encoding_Opt, s_encoding, sizeof(encoding_Opt));
+	encoding_Opt[sizeof(encoding_Opt)-1] = 0;
+}
+
+char * get_input_buff(size_t *psize) {
+	return encoder_getbuff(p_encoder, ENC_IN, ENC_WRITE, psize);
+}
+
+void enc_fprintf(FILE * stream, const char * format, ...) {
+	va_list va;
+	va_start(va, format);
+	encoder_vprintf(p_encoder, stream, format, va);
+	va_end(va);
+}
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/lisp.c juman-7.01/lib/lisp.c
--- B:/msys64/tmp/juman-7.01/lib/lisp.c	Sun Aug 28 12:46:49 2011
+++ juman-7.01/lib/lisp.c	Wed Oct 25 16:58:15 2017
@@ -48,6 +48,7 @@ CELLTABLE	CellTbl_save;
 */
 extern int fgetc(FILE *fp);
 extern int ungetc(int c, FILE *fp);
+extern int dividing_code_p(int code);
 
 static int (*my_getc)(FILE *fp) = fgetc;
 static int (*my_ungetc)(int c, FILE *fp) = ungetc;
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/Makefile.in juman-7.01/lib/Makefile.in
--- B:/msys64/tmp/juman-7.01/lib/Makefile.in	Mon Dec 15 09:50:09 2014
+++ juman-7.01/lib/Makefile.in	Sun Oct 29 14:41:47 2017
@@ -72,8 +72,11 @@ LTLIBRARIES = $(lib_LTLIBRARIES)
 libjuman_la_LIBADD =
 am_libjuman_la_OBJECTS = connect.lo getid.lo grammar.lo iotool.lo \
 	katuyou.lo lisp.lo pat.lo patfile.lo zentohan.lo juman_lib.lo \
-	japanese.lo
+	japanese.lo encoder.lo ext_api.lo json_parse.lo
 libjuman_la_OBJECTS = $(am_libjuman_la_OBJECTS)
+libjuman_OBJECTS = connect.o getid.o grammar.o iotool.o \
+							katuyou.o lisp.o pat.o patfile.o zentohan.o juman_lib.o \
+							japanese.o encoder.o ext_api.o json_parse.o
 libjuman_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(libjuman_la_LDFLAGS) $(LDFLAGS) -o $@
@@ -209,9 +212,10 @@ target_alias = @target_alias@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-include_HEADERS = juman.h juman_pat.h
+include_HEADERS = juman.h juman_pat.h ext_api.h
 lib_LTLIBRARIES = libjuman.la
-libjuman_la_SOURCES = connect.c const.h getid.c grammar.c iotool.c katuyou.c lisp.c pat.c patfile.c zentohan.c juman.h juman_lib.c juman_pat.h japanese.c
+libjuman_la_SOURCES = connect.c const.h getid.c grammar.c iotool.c katuyou.c lisp.c pat.c patfile.c zentohan.c juman.h juman_lib.c juman_pat.h japanese.c \
+											encoder.h encoder.c ext_api.h ext_api.c json_parse.h json_parse.c
 libjuman_la_LDFLAGS = -version-info @LIBJUMAN_VERSION_INFO@
 all: all-am
 
@@ -281,6 +285,13 @@ clean-libLTLIBRARIES:
 libjuman.la: $(libjuman_la_OBJECTS) $(libjuman_la_DEPENDENCIES) 
 	$(libjuman_la_LINK) -rpath $(libdir) $(libjuman_la_OBJECTS) $(libjuman_la_LIBADD) $(LIBS)
 
+libjuman.so: $(libjuman_OBJECTS)
+	$(CC) -shared -Wl,--enable-auto-image-base $(LDFLAGS) \
+		-Wl,--enable-auto-image-base -Xlinker --out-implib -Xlinker $@ \
+		-o $@ $(libjuman_OBJECTS) $(LIBS)
+		cp $@ $(DESTDIR)$(libdir)
+
+
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
 
@@ -298,6 +309,9 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pat.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/patfile.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/zentohan.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/encoder.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext_api.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/json_parse.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/lib/pat.c juman-7.01/lib/pat.c
--- B:/msys64/tmp/juman-7.01/lib/pat.c	Fri Jul  1 13:14:19 2011
+++ juman-7.01/lib/pat.c	Wed Oct 25 16:59:21 2017
@@ -48,6 +48,9 @@ static struct _dic_t {
   caddr_t addr;
 } dicinfo[MAX_DIC_NUMBER];
 
+extern int hash_check_proc(FILE *f, long index, char *buf);
+ 
+
 /******************************************************
 * pat_strcmp_prefix --- プレフィクスマッチ
 *
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/makeint/makeint.c juman-7.01/makeint/makeint.c
--- B:/msys64/tmp/juman-7.01/makeint/makeint.c	Thu Sep 15 08:43:32 2011
+++ juman-7.01/makeint/makeint.c	Wed Oct 25 17:10:46 2017
@@ -96,9 +96,9 @@ void translate(char *arg)
 
 int main(int argc, char *argv[])
 {
-     long	t0, t1;
-     long	p0, p1;
-     int	dt, i;
+     time_t	t0, t1, dt;
+     clock_t p0, p1;
+     int	i;
      float	dp;
 
      ProgName = argv[0];
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/makeint/trans.c juman-7.01/makeint/trans.c
--- B:/msys64/tmp/juman-7.01/makeint/trans.c	Fri Aug 26 11:04:44 2011
+++ juman-7.01/makeint/trans.c	Wed Oct 25 17:06:29 2017
@@ -40,6 +40,8 @@ static 	MRPH 		mrph;
 static  MRPH            mrph_buffer[MRPH_BUF_MAX];
 static  int             mrph_buffer_num;
 
+int hankaku_check(U_CHAR *s);
+
 enum	ErrorCode	{NotList, IllegalForm, ConflictGobi,
 			   NoMidasi, LongMidasi, 
 			   NoYomi,   LongYomi, 
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/makemat/makemat.c juman-7.01/makemat/makemat.c
--- B:/msys64/tmp/juman-7.01/makemat/makemat.c	Thu Sep 15 08:43:45 2011
+++ juman-7.01/makemat/makemat.c	Thu Oct 26 12:56:41 2017
@@ -11,7 +11,7 @@
 #include	"makemat.h"
 
 #define         KANKEI_MAX      100
-#define         REN_TBL_MAX     6000
+#define         REN_TBL_MAX     8000
 #define         REN_MTR_MAX     6000
 
 /*
diff -rupBN -x *dic -x perl -x stamp-h1 -x winconf -x jumanrc -x libtool -x .libs -x .deps -x config.* -x *.log -x *.o -x *.lo -x *.a -x *.la -x *.so -x *.exe -x Makefile B:/msys64/tmp/juman-7.01/makepat/makepat.c juman-7.01/makepat/makepat.c
--- B:/msys64/tmp/juman-7.01/makepat/makepat.c	Thu Sep 15 08:48:28 2011
+++ juman-7.01/makepat/makepat.c	Wed Oct 25 17:12:32 2017
@@ -24,7 +24,7 @@ int number_of_tree = 0; /* 使用する
 /****************************************************
 *                      メイン                       *
 ****************************************************/
-main(int argc, char *argv[])
+int main(int argc, char *argv[])
 {
   char comm;
   int i;
